#! /usr/bin/env python3
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 8.1
#  in conjunction with Tcl version 8.6
#    Nov 16, 2025 08:17:48 PM CST  platform: Linux


#System imports
import socket
import os
import sys
from time import sleep
import struct
import serial

#Tkinter imports
import tkinter as tk
import tkinter.ttk as ttk
from tkinter import Frame, Label, Button, Text, Radiobutton, messagebox
from tkinter.messagebox import showinfo
from tkinter import filedialog as fd
from tkinter import scrolledtext
from tkinter.constants import *

#PILLOW imports
import PIL.Image
import PIL.ImageTk
import PIL.ImageDraw
import PIL.ImageFont
import PIL.ImageChops
import PIL.ImageOps

import myCTP


#COMMUNICATION LOGIC STARTS HERE
rfcomm_port = '/dev/rfcomm0'
scriptDir = os.path.dirname(os.path.abspath(sys.argv[0])) #get the path to the directory containing the app
fontName=os.path.join(scriptDir, "Lucon.ttf")
fontSize="18"
fontSize_int=18

printerWidth = 384  # For CPT500
_debug = True # False to eliminate debug printing from callback functions.

def main(*args):
    '''Main entry point for the application.'''
    global root
    root = tk.Tk()
    root.protocol( 'WM_DELETE_WINDOW' , root.destroy)
    # Creates a toplevel widget.
    global _top1, _w1
    _top1 = root
    _w1 = myCTP.Toplevel1(_top1)
    _w1.TCombobox1_1.set(fontSize)

    root.mainloop()

class PrinterConnect: # Starting a PrinterConnect class to keep track of connection status
    def __init__(self, serial_port='/dev/rfcomm0'):
        # Initialize connection status variables
        self.socket = None  # This can be kept or removed since you use self.ser now
        self.ser = None     # Serial object reference
        self.connected = False  # Setting connection status to False/disconnected
        self.port_name = serial_port # Store the port name

        # Call the connection logic immediately on startup
        self._auto_connect()

    def _auto_connect(self): # This is the function that was previously called 'connect'
        serial_port = self.port_name
        if self.connected:
            print("Already connected")
            return True

        try:
            # Baud rate is usually ignored for RFCOMM, but required
            self.ser = serial.Serial(serial_port, 9600, timeout=1) 
            print(f"Connected to {serial_port}")
            self.connected = True
            return True
        except Exception as e:
            print(f"Auto-connection error: {e}")
            # Use tk.messagebox.showerror here if this is where you want the popup
            # tk.messagebox.showerror("Connection Error", f"Failed to connect: {e}\nEnsure the printer is ON and bound.") 
            return False

    def disconnect(self): # Function to disconnect the serial port
        if not self.connected or not self.ser:
            print("Not connected")
            return

        try:
            print("Disconnecting printer")
            self.ser.close() 

            print("Clearing serial port references")
            self.ser = None
            self.connected = False
            print("Disconnected")

        except Exception as e:
            print(f'Disconnection error: {e}')
            if self.ser:
                self.ser.close()
                self.ser = None
            self.connected = False

    def get_printer_status(self):
        if not self.ser:
            raise Exception("Not connected")
        self.ser.write(b"\x1e\x47\x03") # Hex code for status request
        return self.ser.read(38) # Returning status request content

#Create a printer connection instance here. Having it *outside* of a function lets us run and monitor connection across global scope
printer = PrinterConnect(serial_port='/dev/rfcomm0') 
#PRINTER COMMUNICATION LOGIC AND SETUP ENDS HERE


#IMAGE DATA STORAGE STARTS HERE
current_image = None #Variable to store full resolution image
image_thumbnail = None #Variable to store image thumbnail
image_preview = None #Variable to store image preview for PhotoImage and canvas
#IMAGE DATA STORAGE ENDS HERE

#TEXT FILE MANAGEMENT STARTS HERE
def selectTextFile(gui_instance):
    textFilePath = fd.askopenfilename(
        title = "Open a text file",
        initialdir = "/"
    )

    showinfo(
        title="Selected file: ",
        message = textFilePath
    )

    if textFilePath:
        try:
            with open(textFilePath, 'r', encoding='utf-8') as textFile: #Using the file path we got from the user to read the file
                textFileContent=textFile.read()
                gui_instance.Text1_1.delete('1.0', tk.END) #Clearing previously typed content
                gui_instance.Text1_1.insert(tk.END, textFileContent) #Inserting the text file content

            #Insert some sort of status bar system here? Success messages and exception messages
            #Status Bar stuff
        except Exception as e:
            print("Woops, something went wrong.")
            
#TEXT FILE MANAGEMENT ENDS HERE

#TEXT AND IMAGE INPUT RENDERING AND PRINTING STARTS HERE
def changeFont(gui_instance):
    fontSize = gui_instance.TCombobox1_1.get()
    print(f"Font size (string) is {fontSize}")
# Convert the string to an integer if needed for font functions
    try:
        fontSize_int = int(fontSize)
        print(f"Selected font size as integer: {fontSize_int}")
    except ValueError:
        print(f"Error: Could not convert '{fontSize}' to a number.")
        
# Update the text field
    gui_instance.Text1_1.configure(font=(fontName,fontSize))

def create_text(text, font_name="Lucon.ttf", font_size=12):
    print(f"Font size being printed is {font_size}.")
    #Tweak to be able to change font w/ system fonts
    img = PIL.Image.new('RGB', (printerWidth, 5000), color=(255, 255, 255)) #Defines an RGB image, width is printer width, height is 5000px, color is white
    font = PIL.ImageFont.truetype(font_name, font_size) #Loads up font_name as the default font, at font_size default size

    d = PIL.ImageDraw.Draw(img) #Creates the d image object using the parameters above
    lines = [] #Creates an empty Python list to store lines of text
    for line in text.splitlines(): #Combing through text looking for line splits
        lines.append(get_wrapped_text(line, font, printerWidth)) #Creating a new lines list item at each line split
    lines = "\n".join(lines) #Recombining all the lines list items with a "\n" line jump instruction at each line break
    d.text((0, 0), lines, fill=(0, 0, 0), font=font) #Drawing our text onto our d object
    return trimImage(img) #Trimming down the unused height of the d object using the trimImage() function above

def get_wrapped_text(text: str, font: PIL.ImageFont.ImageFont, line_length: int): #Function to wrap the text to printer paper width
    lines = [''] #Empty list to store the lines
    for word in text.split(): #Iterating through the split words composing a sentence
        line = f'{lines[-1]} {word}'.strip() #Composing a "candidate line" out of words, one word at a time
        if font.getlength(line) <= line_length: #If the pixel length of the line is shorter than the printer width...
            lines[-1] = line #...We keep doing that!
        else:
            lines.append(word) #...Otherwise we create a new line in the list of lines, and continue from the next word on.
    return '\n'.join(lines) #Done processing the text, returning the lines dictionary as a text with line returns!

def print_from_entry(gui_instance):
    txt = gui_instance.Text1_1.get("1.0", tk.END).strip() # Grab the text from the scrolled-text widget
    if not txt:
        messagebox.showwarning("No text", "Please type or load some text.")
        return
        
    fontSize = gui_instance.TCombobox1_1.get()

# Convert the string to an integer for font functions
    try:
        fontSize_int = int(fontSize)
        print(f"Selected font size as integer: {fontSize_int}")
    except ValueError:
        print(f"Error: Could not convert '{fontSize}' to a number.")
    img = create_text(txt, fontName, fontSize_int) # Turning the text to image

    # Change 1: Check the new serial object (printer.ser) instead of the old socket
    if printer.connected and printer.ser: 
        try:
            # Change 2: Pass the serial object (printer.ser) to all print functions
            initializePrinter(printer.ser) # Initializing printer
            sleep(0.5)
            sendStartPrintSequence(printer.ser) # Starting up print sequence
            sleep(0.5)
            printImage(printer.ser, img) # Passing data to print
            sleep(0.5)
            sendEndPrintSequence(printer.ser) # Sending end of print sequence
            
            #messagebox.showinfo("Success", "Printed successfully.") # Optional success message
        except Exception as e:
            messagebox.showerror("Printing error", str(e))
    else:
        messagebox.showwarning("Not connected", "Please connect to the printer first.")

def print_from_image(gui_instance):
    """Send the currently loaded image to the printer."""
    if not current_image:
        messagebox.showwarning("No image", "Please load an image first.")
        return

    if not (printer.connected and printer.ser):
        messagebox.showwarning("Not connected",
                               "Please connect to the printer first.")
        return

    try:
        print("Initializing printer")
        initializePrinter(printer.ser)
        sleep(0.5)

        print("Starting print sequence")
        sendStartPrintSequence(printer.ser)
        sleep(0.5)

        # THIS is where we actually hand the image over
        print("Printing image")
        printImage(printer.ser, current_image)

        print("Sending end sequence")
        sleep(0.5)
        sendEndPrintSequence(printer.ser)

        messagebox.showinfo("Success", "Image printed successfully.")
    except Exception as e:
        messagebox.showerror("Printing error", str(e))

#IMAGE FILE SECTION STARTS HERE
def selectImageFile(gui_instance):
    global current_image, image_thumbnail, image_preview
    imageFilepath = fd.askopenfilename(
        title = "Open an image file",
        initialdir = "/",
        filetypes = (('PNG files', '*.png'), ('JPG files', '*.jpg'), ('jpeg files', '*.jpeg'), ('BMP files', '*.bmp'), ('SVG files', '*.svg'), ('all files', '*.*'))
        )

    showinfo(
        title="Selected file: ",
        message = imageFilepath
    )

    if imageFilepath:
        try:
            print("Opening image file")
            current_image = PIL.Image.open(imageFilepath, 'r') #Storing the image contents into imageFile variable
            print(current_image)

            print("Generating preview")
            imageCanvas_width = gui_instance.imageCanvas.winfo_width() #Storing the width of the preview canvas
            imageCanvas_height = gui_instance.imageCanvas.winfo_height() #Storing the height of the preview canvas
            imageCanvas_x_center = imageCanvas_width//2 #Calculating x center of the preview canvas
            imageCanvas_y_center = imageCanvas_height//2 #Calculating y center of the preview canvas
            
            image_thumbnail = current_image.copy() #Copying current_image into image_thumbnail
            print(image_thumbnail)
            image_thumbnail.thumbnail((imageCanvas_width, imageCanvas_height)) #Resizing image_thumbail to canvas size (might not work)

            image_preview = PIL.ImageTk.PhotoImage(image_thumbnail) #Storing the thumbnail as a displayable object into image_preview
            gui_instance.imageCanvas.delete('all')  #Clearing any  previous image from the canvas display
            gui_instance.imageCanvas.create_image(imageCanvas_x_center, imageCanvas_y_center, anchor = "center", image=image_preview)  # Loading up the thumbnail into the center of the preview canvas

        except Exception as e:
            print("Whoops, something went wrong.")
            print({e})
#IMAGE FILE SECTION ENDS HERE

def printImage(serialport, im):
    if im.width > printerWidth:
        # Image is wider than printer resolution; scale it down proportionately
        height = int(im.height * (printerWidth / im.width))
        im = im.resize((printerWidth, height))

    if im.width < printerWidth:
        # Image is narrower than printer resolution; pad it out with white pixels
        padded_image = PIL.Image.new("1", (printerWidth, im.height), 1)
        padded_image.paste(im)
        im = padded_image

    #Add a function for text rotation
    # im = im.rotate(180)  # Print it so it looks right when spewing out of the mouth

    # If image is not 1-bit, convert it
    if im.mode != '1':
        im = im.convert('1')

    # If image width is not a multiple of 8 pixels, fix that
    if im.size[0] % 8:
        im2 = PIL.Image.new('1', (im.size[0] + 8 - im.size[0] % 8, im.size[1]), 'white')
        im2.paste(im, (0, 0))
        im = im2

    # Invert image, via greyscale for compatibility
    im = PIL.ImageOps.invert(im.convert('L'))
    # ... and now convert back to single bit
    im = im.convert('1')

    buf = b''.join((bytearray(b'\x1d\x76\x30\x00'),
                    struct.pack('2B', int(im.size[0] / 8 % 256),
                                int(im.size[0] / 8 / 256)),
                    struct.pack('2B', int(im.size[1] % 256),
                                int(im.size[1] / 256)),
                    im.tobytes()))

    serialport.write(buf)

def trimImage(im):
    bg = PIL.Image.new(im.mode, im.size, (255, 255, 255))
    diff = PIL.ImageChops.difference(im, bg)
    diff = PIL.ImageChops.add(diff, diff, 2.0)
    bbox = diff.getbbox()
    if bbox:
        return im.crop((bbox[0], bbox[1], bbox[2], bbox[3] + 10))  # Don't cut off the end of the image

def initializePrinter(soc):
    soc.write(b"\x1b\x40")

def sendStartPrintSequence(soc):
    #Check against hex dump
    soc.write(b"\x1d\x49\xf0\x19")

def sendEndPrintSequence(soc):
    #Check against hex dump. Missings \x9a?
    soc.write(b"\x0a\x0a\x0a\x9a")

#TEXT AND IMAGE INPUT RENDERING AND PRINTING ENDS HERE







#if __name__ == '__main__':
#    myCTP.start_up()




